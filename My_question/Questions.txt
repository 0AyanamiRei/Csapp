关于链接一章的一些疑问：
    *首先确认一个事实，GOT中我们仅仅为每一个目标文件引用过的"函数"或"全局变量"创建一个8-byte的entry
    *编译器为GOT中每一个entry生成重定位记录, 在load的时候才会重定位这些entry，以此获得这些"函数"和"全局变量"
    *的绝对地址。也就是说在库中大量没有被引用过的函数和变量就不会被记录更不会被重定位。
    *
    *在这个事实的上面我们提问，既然我们可以在链接器重定位之前就获得"哪些函数被引用过"
    *这样的信息，那么是否使用lazy binding对程序运行的开销节省体现在哪儿呢？无用的重定位又是从何谈起。
    *
    *我的理解是，对于一些有分支的代码段，比如if(A){ func1();}  else{func2();}
    *使用lazy binding技术就可以仅仅重定位func1或者func2，而不是在加载的时候就把func1和func2都进行重定位。
    ************************************************************************************************************
    ↑已解决


关于异常控制流一章的一些疑问：
    *信号处理函数的原型void handler(int sig)， 为什么说其返回值无法被捕获，当前进程调用的信号处理函数
    *返回给当前进程中的变量有什么问题吗？
    *
    *根据大模型的回答：
    *在C语言中，信号处理函数的原型是 `void handler(int sig)`，这意味着它们没有返回值。"设计就是这样的"是指这是
    *C语言和操作系统设计者决定的。当操作系统接收到一个信号时，它会暂停当前进程的执行，然后调用相应的信号处理函数。
    *当信号处理函数返回时，操作系统会恢复进程的执行。因为信号处理函数的原型是没有返回值的，所以操作系统并不会去获取
    *或使用信号处理函数的返回值。这样设计的原因是，信号处理函数主要用于处理异步事件，例如用户按下Ctrl+C，或者一个子进程结束。
    *这些事件可以在任何时候发生，因此信号处理函数需要尽可能快地执行完毕，然后让程序继续执行。如果信号处理函数有返回值，
    *那么就需要有某种机制来接收这个返回值，这会使得信号处理变得更复杂，也可能会导致程序在等待信号处理函数的返回值时被阻塞
    *这都是我们不希望看到的。
    *
    *因此，如果你需要在信号处理函数中传递数据给其他函数，你需要使用其他的方法，例如全局变量，管道，消息队列，或者共享内存。
    *
    *再检查一下代码中是如何使用信号处理函数的,我们发现也没有办法去修改这一规定(接受信号处理函数的返回值)
    ****************************************************************************************************************
    ↑已解决