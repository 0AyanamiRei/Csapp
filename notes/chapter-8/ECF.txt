

##8.4 System Call Error Handling与Process Control#####
    Unix系统级函数调用遇到错误一般会返回-1，且设置全局变量errno来表示出的是什么错误。
    
    这里对fork()使用Fork()是一个很好的习惯,即对于函数foo,我们定义一个包装函数Foo调用基本函数来检查错误
    这样可以避免代码臃肿.
    介绍一些函数 fork()、getpid()、getppid()、exit()
    下面以具体的例子介绍如何创建、回收、控制一个进程


  # 创建子进程 # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # #
  # 关于fork()函数"调用一次,返回两次",结合图8-15所示的程序与我自己添加的一些输出信息可以意识到:(假设调用成功)
  # ·fork()在(父)当前进程被调用
  # ·调用成功，则copy一份当前进程的包括代码、数据、用户栈等信息的副本，作为(子)新开进程的初始状态
  # ·fork返回(子)新开进程的PID给(父)当前进程, 返回0给(子)新开进程
  #
  # 对于进程图，这里贴一张：
  #  
  #        父进程的副本->返回值=0---------→printf(·)---->exit
  #                   ↑
  # main(·)---→fork()--->返回值=子进程PID--→printf(·)---->exit
  #
  # 顺带的检测一下：
  # Fork();
  # Fork();
  # printf("hello\n");
  # exit(0);
  # 运行这样的程序会输出多少条hello？(答案是4 1->2->4)
  # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # #



  # 回收子进程 # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # #
  # 一个进程的回收不是当它终止时，而是保持一种"终止"的状态等待被父进程回收(reaped)
  # 如果父进程没有回收它的僵死子进程，称这个子进程为孤儿进程，会被init进程(别忘了系统启动时候也会创建一个进程)
  # "领养"，init进程的PID=1，它不会终止
  #
  #
  #
  #
  #
  #
  #
  #
  #
  #
  #
  #
  #
  #
  #