Book practice

##练习5.5########################################################################
多项式求值函数
double poly_1(double a[], double x, long n)
{
    long i;
    double res = a[0];
    double xpwr = x;
    for(i = 1; i <= n; i ++){
        res += a[i] * xpwr;
        xpwr = x * xpwr;
    }
    return res;
}
double poly_2(double a[], double x, long n)
{
    long i;
    double res = a[d];
    for(i = n - 1; i >= 0; i --){
        res = a[i] + x * res;
    }
    return res;
}
#1分析两种风格的代码执行多少次加法和多少次乘法运算？
#2计算两个代码的CPE。
#3解释为什么第二个函数CPE需要更多操作但是运行更快？

我们只关注循环体的计算次数，poly_1的计算次数需要2n次乘法和2n次加法。
poly_2需要2n次加法，n次乘法。

绘制二者的数据流图，只关注循环体部分,便可得知poly_1的CPE是5n,而poly_2是8n
但是poly_2的n是前者的一半,所以整体上是poly_2更快，这提醒我们优化一个程序时，不能仅考虑降低其CPE
而是应该综合考虑其循环次数n和CPE。



##练习5.9########################################################################
void merge(long src1[], long src2[], long dest[], long n) {
    long i1 = 0;
    long i2 = 0;
    long id = 0;

    while (i1 < n && i2 < n) {
        if (src1[i1] < src2[i2]) dest[id++] = src1[i1++];
        else dest[id++] = src2[i2++];
    }
    while (i1 < n) dest[id++] = src1[i1++];
    while (i2 < n) dest[id++] = src2[i2++];
}

i1 i2与n的比较是非常好预测的，唯一一次错误发生在它们第一次超过n时
但是src1[i1]和src2[i2]之间的比较对于随机的数据是很难预测的，当运行在随机数据上时
这个比较控制一个条件分支 CPE大约在15.0 (元素数量为2n)

重写代码使得用一个条件传送语句实现第一个循环中的条件语句，即：
if (src1[i1] < src2[i2]) dest[id++] = src1[i1++];
else dest[id++] = src2[i2++];

re：
    long sign = src1[i1] < src2[i2];
    dest[id++] = sign ? src1[i1] : src2[i2];
    i1 += sign;
    i2 += 1-sign;
    
    舍弃三目运算符呢？ dest[id++] = sign * src1[i1] + 1-sign * src2[i2];

仔细查询资料后，比较了条件数据传送和条件控制转移的区别

条件数据传送就是先将条件分支的多个值计算出来，举一个现实生活中的例子
今天想要和朋友去旅游，但是你不知道朋友想去a地还是b地
条件控制转移的做法：
    想去a地，就准备a地的攻略、酒店安排等；想去b地，就准备b地的攻略、酒店安排等
条件数据传送的做法：
    同时准备a地和b地的攻略、酒店安排、行程，得到朋友消息后就立刻出发。

条件数据传送这样做可能比较耗费资源，但是cpu计算是可以并行做多件事的，所以可以很好的提高性能
但是需要注意的是，如果各个分支的开销太大了，使用条件数据传送是不好的。

